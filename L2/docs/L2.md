# Etherium Layer 2

## What is layer 2?
Layer 2  (L2) is a term combining different scaling approaches with aim of greater transaction speeds, lower gas fees and different governing solutions in combination with [Etherium][1] main net, while trying to remain as secure as possible. Etherium Layer 2 network is in fact a separate blockchain that extends Etherium.

## How it works
Different L2 approaches use [different solutions][2] to extend Etherium main net (L1). This include bundling transactions on L2 chain and submitting them to L1 (rollups), running parallel payment channel and only submitting balance to main net when closing channel (State / payment channels), 

## Rollups
Rollups are the the most promising L2 solutions. The main idea behind this approach is to preform transactions off chain, possibly on another side chain, periodically  bundling them together and submitting them to L1 network. 

Rollups have many benefits over using bare main net. By combining multiple transactions into one, main net's gas fees get distributed over the whole bundle, which makes them much cheaper. They also increase speed while still maintaining a high level of security, which is derived from Etherium main network. 

There are two different approaches: Optimistic rollups and zero-knowledge rollups.
### Optimistic rollups
[Optimistic rollups][3] batch transactions in one bundle and submit them to main net. The name `optimistic` comes from the fact that rollups by default assume all submitted transactions are **valid** and do not perform proofs or submit them to main chain. Instead, this approach employs a `fraud-prevention` scheme in which any node can challenge the result. After so-called challenge period (which lasts cca. 7 days) passes, transactions are deemed valid and are accepted to Etherium mainnet.

Optimistic rollups have many benefits. As most of L2 approaches, they offer up to 100x decrease in gas fees  while still maintaining high level of security and trustlessness. Execution is transparent, transaction data is stored on L1. Fraud proving is open to **any node** **without special hardware** which makes the process highly decentralized. Security is achieved by respecting minorities, even one honest node can submit a  successful **fraud challenge**, which is respected. Security is further increased by well-designed **cryptoeconomic model**, where rollup operators must provide a bond, which gets slashed in case of dishonesty. And finally, compatibility with EVM and solidity simplifies porting dApps between L1 and L2  nets.

This approach also has some drawbacks. The biggest being a huge **delay in transaction finality**, where transactions are only considered valid after a long challenge period, which lasts roughly 7 days. This makes really long delay in transferring funds L2 > L1, while L1 > L2 usually takes a couple of minutes. Long delay can be hedged using **liquidity providers**, which, for a fee, assume ownership of pending L2 withdrawal and compensate by other funds already on L1. Another drawback is a possibility of malicious attack in case no node is honest. Since transactions are not validated unless at least one of the nodes submits a challenge, if no node does it, attack can succeed. This, hoverer is a highly unlikely event, which makes optimistic rollups a very secure L2 solution. 

### Zero-knowledge rollups
A [zero-knowledge rollups][4] (zk-rollups) work  similarly then optimistic rollups. They also perform transaction on separate L2 layer, combine them into one bundle but there ends similarity. Instead of transactions, zk-rollups only submit *last state* of all the accounts in rollup combined with *validity proofs* for the last state. Proofs then get verified on L1 and are accepted as valid transactions. Transactions are therefore deemed final when L1 accepts proofs, which happens in minutes instead of in 7 days, as in optimistic rollups. 

Zk-rollups are usually less decentrialised as optimistic rollups. Role of operator, which combines L2 transactions, also called `sequencer` is usually only preformed by on "supernode", although this role can be passed around according to proof-of-stake system. This is a single point of failure and opportunity for censorship. To prevent this, users can also bypass operator and submit L2 transactions directly to smart contract.

The next phase before submitting transactions to L1 is generation of proofs, which is usually done by proofer. Validity proofs provide evidence that each transaction in batch itself is valid, it is actually contained in batch and that batch as a whole is valid. Proofs then gets checked by L1 smart contract.

Zk-rollups have many benefits over other approaches. Validity proofs guarantee with **cryptographic certainty** the correctness of transactions, which can easily be checked.  Therefore, there is no 7d days "challenge period", as with optimistic rollups, which makes for much **faster transaction finality**. Data is stored on L1, which brings **transparency and resiliency**. Since data is compressed, the cost of publishing it on Etherium low which brings **lower fees** for transactions, even lower then optimistic rollups.

This approach also has some drawbacks. For starter, generation of proofs is a costly endeavour, which can **increase transaction fees**. Generation of proofs require some adjustments. They require **specialized hardware**, and specialized **zk-rollups-compatible EVM**, which is hard. All the difficulties **lower the number of participants** in the network,  which consequently lowers decentralization and security. Some implementation of proof generation (ZK-SNARK) also require **trusted environment**, which is another vulnerability. 


## State channels
A [state channel][5] is a scaling solution, which enables two parties to exchange a series of transactions or state updates off chain in a secure way. It works by two parties depositing their funds on a smart contract on mainnet. This deposits work as a virtual tab, a money, which parties can use for transactions between them. After that, parties can start exchanging transactions or state updates. Every state update is initiated by one party, signed and then sent to other party for approval. After it is also signed by other party, the state is deemed valid. This mechanism is called *multisig contract*. When one of the parties wants to close the channel, they submit last agreed upon state back to mainnet. For security reasons, the submitted state is only accepted after a *challenge window*, during which anyone can dispute the proposed state update by submitting *newer state*. At the end, the most recent state is accepted, funds redistributed and channel closed.

Naive implementation of state channel requires deployment of smart contract on main net every time, two parties want to open a new state channel, which can be quite expensive and extremely inefficient. The solution for this issue is a **virtual state channel**, which can open or close new channel without the need to submit a contract to Etherium. It works using so called *ledger channels*, which are defined using smart contracts, deployed on mainet. Other users then open a new virtual state channel on top of some ledger chanel, where owner(s) of ledger channel assume the role of intermediary.

State channels are extensively used in paying services, since they support far greater number of transactions at much lower cost, then Etherium mainnet. They are popular option for executing microtransactions, reoccurring transactions between two parties. Some popular blockchain payment services build on top of **virtual payment channels** which allows, to route funds through intermediaries without the need to establish peer-to-peer connection between each pair of users. State channels can also support deployment of decentralized application, although it is usually limited to simple turn-based applications.

State (payment) channels also have quite a few drawbacks. Since dispute resolution requires users to respond to malitious attemts, a precondition for this security feature is for user to always be online. In case of going offline, user can open a door for potential attacks from other side of state channel. Similarly, since state updates are not saved publicly on Etherium blockchain, users must keep their own copies of last signed state. Another possibility for attack is so called *griefing attack*. Since every user must respond to every dispute, an attacker can continually be making invalid dispute claims. Since dispute resolution happens on-chain, it can cost a lot of money. This does not bring direct benefit to attacker but can still cause a lot of harm for the victim.

Another set of drawbacks arises from design of state channels. A precondition for establishing state channel is for the both parties to deposit their funds into smart contract, which some users cannot afford. This is mitigated by the use of virtual state channels, which can open an close channel anytime and as many times as needed. Another limitation is the fact state channels can support a limited number of participants, with every addition happening on-chain. This can also be mitigated with virtual ledger channels.


## Sidechains

[Sidechains][6] are separate chains, which are connected to Etherium mainnet via bridges. Sidechain can have its own block parameters, consensus algorithm, but do not derive its security features from mainnet, since changes are not posted back to L1, as is done with real L2 solutions like rollups.

Sidechains have can have different **consensus algorithm** than Etherium mainnet, which uses proof of work. Among popular choices are Proof of stake, Proof of Authority, Delegated proof of steak or Byzantine fault tolerance.

Another differentiator are **block parameters**. Etherium places limit on block size and block times, while side chains can choose different parameters, for instance greater block sizes, lower block times etc. This can increase dificulty of running a node, leading to smaller degree of decentralization.

Most of sidechains are **EVM-compatible**, which means they can run the sam smart contracts as L1. This ease transfer of dApps from L1 to sidechain, thus allowing developers to experiment with different features with lower costs, but with less (or no) security guarantees.

One of the most important aspects of sidechains are **bridges**, which allows for movement of assets between Etherium and sidechain, or different sidechains. Bridges are essentially smart contracts, deployed on Etherium. While bridges do not physically transfer funds, they work as a sort of exchanges, using different approaches, for instance burning or minting assets.

Benefits of sidechain include usage of well established and tested technology and (generally) compatibility with mainnet, which allows for developer to enjoy lower fees while testing with different network parameters, consensus algorithms etc., they provide this features at the cost of lower decentralization and do not inherit Etherium's security guarantees. Another vulnerability are network bridges, which are essential for moving assets to and from sidechain, but can be an easy target. Nevertheless, sidechains offer a great alternative to more complex scaling solutions, like rollups, state channels or plasma, which is ideal in some settings.  

## Plasma
https://ethresear.ch/t/minimal-viable-plasma/426

## Validium



















[1]: <https://ethereum.org/en/layer-2/>
[2]: <https://ethereum.org/en/developers/docs/scaling/>
[3]: <https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/>
[4]: <https://ethereum.org/en/developers/docs/scaling/zk-rollups/>
[5]: <https://ethereum.org/en/developers/docs/scaling/state-channels/>
[6]: <https://ethereum.org/en/developers/docs/scaling/sidechains/>